## 2025-02-14 — GUI подход для M1

**Контекст.** Платформа DaVinci Resolve 20. В тексте спецификации (FR1, Constraints) требуется окно с кнопками Analyze/Stop, при этом подчёркнута необходимость fallback-а на PyQt для бесплатной версии Resolve. На данный момент в репозитории отсутствует какой-либо UI-код, а основной раннер (`scripts/pigmentbucket_run.py`) рассчитан на выполнение внутри Resolve.

**Опции.**
1. Использовать Resolve UI Manager — обеспечивает родной UI, но доступен только в Studio-версии и сложен для локальной разработки без установленной Resolve.
2. Использовать внешнее PyQt-окно — работает и в Free-версии, можно запускать вне Resolve, проще тестировать, но требует зависимости PyQt и IPC/интеграции с раннером.

**Решение.** На этапе M1 реализуем внешний PyQt-контейнер как основной UI. Это удовлетворяет требованию fallback, позволяет быстро построить скелет интерфейса и интегрировать существующий пайплайн через обёртку. В дальнейшем при необходимости можно добавить Studio-специфичную реализацию на UI Manager.

**Последствия.**
- Добавляем зависимость `PyQt6` (с проверкой лицензии LGPL/GPL) в `requirements.txt` и инструкции по установке в runbook.
- Создаём модуль `scripts/pigmentbucket_gui.py`, где UI управляет запуском раннера и отображением логов.
- Архитектурно отделяем контроллер, чтобы позже возможно было добавить Resolve UI Manager без переписывания бизнес-логики.

## 2025-02-14 — Архитектура пайплайна анализа (Sampler/Features/Clusterer)

**Контекст.** Спецификация (solution.md) требует многоступенчатого пайплайна: Sampling → Feature Extraction → Clustering. Пока сервис `src/service/app.py` генерирует фиктивные кластеры, что мешает поэтапной реализации M2–M3 и затрудняет тестирование отдельных шагов.

**Решение.** Выделяем модуль `src/pipeline/` с явными компонентами:
- `sampler.py` — интерфейс `Sampler` и базовый stub-имплементация.
- `features.py` — интерфейс `FeatureExtractor` и базовый stub.
- `clusterer.py` — интерфейс `Clusterer` и детерминированный placeholder.
- `analyzer.py` — координирует вызовы sampler → features → clusterer и возвращает структурированный `AnalysisResult`.
- `types.py` — общие датаклассы (FrameSample, ClipFeatures, ClipAnalysis, AnalysisResult).

**Последствия.**
- FastAPI-сервис больше не генерирует кластеры напрямую, а вызывает `Analyzer`, что упрощает замену заглушек на реальные алгоритмы.
- Можно по отдельности тестировать sampler/feature/clusterer и внедрять зависимости (например, ffmpeg) без изменений сервиса.
- Следующие итерации (реальный sampling, фичи, кластеризация) будут локализованы в `src/pipeline/`, не затронув API слой.

## 2025-02-15 — Run-ID, Stop и Undo

**Контекст.** Спецификация (FR3, FR4, NFR4) требует безопасной остановки анализа и возможности откатить последний запуск. Текущий раннер применяет цвета напрямую, сервис не хранит историю и не знает о run-id, а GUI/CLI не предоставляют Undo/Stop.

**Решение.**
- Ввести run-id (UUID) для каждого запуска. Раннер генерирует его, передаёт сервису и сохраняет локальный снимок исходных цветов клипов (`undo/<run_id>.json`).
- Пайплайн работает через “commit” фазу: сервис возвращает результат, раннер записывает отчёт и артефакт Undo, после чего цветовому применению присваивается run-id (например, через Resolve marker/metadata). Если Stop нажали до commit — изменения не применяются.
- Undo командой (`scripts/pigmentbucket_run.py --undo <run_id>`) и в GUI: раннер считывает артефакт, восстанавливает цвета, удаляет маркер run-id. Сервис обновляет статус job → `undone` в SQLite.
- Сервис хранит run-id и выбранную палитру в таблице jobs, чтобы История показывает, был ли job отменён/undo.

**Последствия.**
- CLI/GUI получают команды Stop/Undo, отчёты включают run-id и путь к артефакту (`undo_path`).
- `logs/` дополняется каталогом `undo/` с JSON-слепками цветов (ограниченная ротация по run-id).
- Требуется синхронно обновить документацию (`run_m0.md`) и инструкции по очистке/истории.

## 2025-02-20 — Feature cache и fallback для k==1

**Контекст.** Повторные прогоны по тем же клипам дублируют sampling/feature extraction и замедляют пайплайн. Авто-подбор числа кластеров (silhouette) часто возвращает k=1, что делает раскраску бессмысленной и создаёт путаницу в Undo.

**Решение.**
1. В `Analyzer` добавлен файловый кэш фич по ключу (media_path, mtime, размер, sampler/feature config) c хранением в `.cache/features/<hash>.npz`.
2. CLI/GUI получают флаг `--ignore-cache`/«Ignore cache» для форсированного пересчёта.
3. При `k==1` раскраска по умолчанию пропускается (`summary.coloring = {"coloring": "skipped", ...}`), Undo не создаётся.
4. Для best-effort fallback добавлен `--force-min-k 2` и чекбокс «Force min clusters», который разбивает материал по самой варьирующей координате.

**Последствия.**
- Повторные запуски по неизменённым клипам значительно быстрее, summary содержит `cache_hits` для диагностики.
- CLI/GUI логируют причину пропуска раскраски; отчёты и CSV остаются обратимо совместимыми.
- Undo-файлы создаются только когда цвета реально применены.

## 2025-02-20 — Улучшения scoping и логирования

**Контекст.** Пользователям сложно понять, какой поднабор клипов реально ушёл в сервис при режимах `--selection inout|selected`.

**Решение.** Дополнительно логируем `effective_mode`, количество клипов и имена первых элементов выборки в CLI/GUI; в GUI добавлены контрольные чекбоксы и таймаут-спинбокс по умолчанию 60 с.

**Последствия.**
- Быстрее выявлять ситуации, когда Resolve API не отдаёт выбранные клипы.
- Интерфейс предоставляет явные тумблеры для force-min-k и игнорирования кэша.

## 2025-02-23 — Location grouping heuristics (M2)

**Контекст.** Для M2 требуются устойчивые «локации», объединяющие схожие клипы между запусками. Нужны сглаживание по длительности и метрика похожести, чтобы локации не прыгали при каждом запуске.

**Решение.**
- Расширили `LocationGrouper`: последовательные сегменты с одинаковым `cluster_id` сливаются; короткие участки поглощаются соседями, поддерживается hysteresis (A–B–A → A). Косинусный порог (`similarity_threshold`, деф. 0.92) объединяет сегменты с близкими центроидами.
- `Analyzer` пробрасывает конфиг (min_duration, threshold, hysteresis) и возвращает локационные метаданные по каждому клипу: span, длительность, количество клипов, centroid.
- Сервис и отчёты сохраняют расширенный блок `locations[...]`, а также отдельный CSV `locations_<job_id>.csv` со сводкой.
- CLI/GUI отображают количество локаций и сводные статистики.

**Последствия.**
- Локации ведут себя детерминированно при повторных запусках (при тех же порогах и входных данных).
- Клиенты (CLI/GUI/отчёты) получают достаточно данных, чтобы визуализировать/экспортировать локации без дополнительной агрегации.
- Дальше можно подключать персистентное хранилище локаций и Resolve-маркеры на том же API.

## 2025-02-22 — Location grouping rollout (M2 groundwork)

**Контекст.** Переход к фазе M2 требует агрегировать последовательные клипы в более крупные "локации", готовя почву для project-level clustering.

**Решение.** Добавлен модуль `src/pipeline/locations.py`, который объединяет последовательные клипы с одинаковым `cluster_id` и сливает короткие сегменты (`min_duration_sec` по умолчанию 3 с). FastAPI возвращает `location_id` для каждого клипа, отчёты содержит карту `{location_id, cluster_id}`, а summary включает счётчик `locations`. CLI/GUI отображают количество локаций.

**Последствия.**
- `location_id` пока алиас cluster-групп, но уже учитывает порог длительности.
- Отчёты JSON/CSV совместимы назад, добавлены новые поля.
- В дальнейшем `LocationGrouper` можно заменить на более сложный анализ без переписывания сервиса/клиентов.

## 2025-02-27 — Location persistence, markers и экспорт-only режим

**Контекст.** Для M2 требуется стабильная идентификация локаций между запусками и удобные артефакты (markers/CSV). Необходимо избежать дублирования ID, обеспечить undo для маркеров и дать пользователю выбор, когда Resolve не нужен.

**Решение.**
- Введено хранилище локаций: по умолчанию SQLite (`state/locations.sqlite`) с таблицами `location_centroids` и `location_aliases`; альтернативно `--locations-store json` пишет отчёт в `state/locations/<job_id>.json` без стабильных ID.
- `LocationStore.assign` сопоставляет новые центроиды с существующими по косинусной метрике (порог из Analyzer config). Summary теперь включает `location_store`, `locations_persisted`, `matched_locations`, `new_locations`, `centroid_dim`.
- CLI добавлены флаги `--locations-store`, `--export-locations-only`, `--add-location-markers`; GUI получил соответствующие контролы плюс спинбоксы Min duration / Similarity и чекбокс Hysteresis.
- `--add-location-markers` ставит два маркера (start/end) на таймлайне Resolve для каждой локации, цвет берётся из палитры кластера. Undo-файл расширен секцией `markers` и при откате удаляет маркеры.
- `--export-locations-only` (и чекбокс в GUI) запускает анализ без SetClipColor и без маркеров, сохраняя только отчёты и CSV.

**Последствия.**
- Повторные прогоны стабильно переиспользуют идентификаторы локаций при неизменных данных; GUI/CLI логируют статистику сопоставления.
- Артефакты Undo полностью восстанавливают состояние (цвета + маркеры), что снижает риск оставленных отметок.
- Документация и тесты обновлены: unit-тесты покрывают оба стора, e2e проверяет новые поля, runbook описывает режимы persistence/markers/export-only.

## 2025-02-28 — Resolve markers и экспорт форматов

**Контекст.** После включения персистентных локаций пользователям потребовалось управлять таймлайновыми маркерами отдельно от раскраски, а также контролировать, какие отчёты генерирует сервис. В GUI не хватало явных настроек и внятного отображения ошибок.

**Решение.**
- В раннер добавлены флаги `--add-resolve-markers`, `--undo-markers`, `--report-format` (json|csv|both). Undo-снимок сохраняет список маркеров; при `--undo` или `--undo-markers` Resolve очищает соответствующие отметки.
- FastAPI-конец формирует JSON/CSV в соответствии с форматом, расширяет `locations_detail` цветами и пишет новые поля (`location_color_name`, `report_format`).
- GUI получил контролы для report format и всех параметров локаций, чекбокс «Add markers», улучшенный диалог ошибок и сводку по persisted/new/matched.
- Добавлены unit-тесты для логики маркеров (Add/Delete) и e2e-проверки репорт-форматов.

**Последствия.**
- Resolve-интеграция стала управляемой: маркеры можно добавлять/удалять независимо от раскраски, undo надёжно восстанавливает состояние.
- Экспорт можно ограничить только CSV или только JSON; отчёты содержат цветовые подписи локаций.
- GUI отражает выбранные параметры и в случае ошибок показывает критический диалог, что упрощает поддержку.
